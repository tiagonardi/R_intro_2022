<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to R - part 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="Tiago Nardi" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="extra.css" type="text/css" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to R - part 2
## üßâ
### Tiago Nardi
### University of Pavia

---





# TO DO: TABELLA CON NA E CATEGORIE
---
## Vectors

Let‚Äôs first create a vector:

```r
x &lt;- c(2, 5, 8, 1, 2)
```
You can access elements inside a vector using their index position, using the square brackets *[ ]*


```r
x[2] # show the second element
```

```
## [1] 5
```
To select multiple elements use the concatenate function

```r
x[c(1,2)] # show the first and second element
```

```
## [1] 2 5
```
---
## Vectors
You can select a slice of the vector using the colon *:*

```r
x[3:5] # show all elements from a starting index (3) to an ending index (5) (slicing)
```

```
## [1] 8 1 2
```
You can combine both methods

```r
x[c(1,3:5)]
```

```
## [1] 2 8 1 2
```
You can get all the elements barring the elements with a minus before it *-*

```r
x[-2]
```

```
## [1] 2 8 1 2
```
---
## Vectors
You can select elements in the vector using logical conditions

```r
x[x &gt; 2] # show all elements greater than 2
```

```
## [1] 5 8
```
To access the vector you have to specify the values *inside* the brackets

Otherwise you apply the logical operation to all elements in the vector

```r
x &gt; 2
```

```
## [1] FALSE  TRUE  TRUE FALSE FALSE
```
---
## Vectors
As you can assign values to an __object__

You can assign values inside a vector


```r
x[3]
```

```
## [1] 8
```

```r
x[3] &lt;- 11 # replace the third element with the number 11
x[3]
```

```
## [1] 11
```

---
## Rows and columns

```r
db &lt;- read.csv("patric_redux.csv", header = T)
db1 &lt;- db # let's make a copy of the data frame
head(db)
```

```
##                                          Genome.Name Contigs Genome.Length
## 1 Yersinia pestis biovar Orientalis str. AS200901539     250       4572127
## 2 Yersinia pestis biovar Orientalis str. AS200902147     277       4592682
## 3 Yersinia pestis biovar Orientalis str. AS200901434     237       4572981
## 4 Yersinia pestis biovar Orientalis str. AS200901509     263       4605070
## 5                               Yersinia pestis 2501     201       4593919
## 6                                Yersinia pestis 24H     140       4492822
##   GC.Content PATRIC.CDS Isolation_location
## 1       47.5       4398           Isengard
## 2       47.5       4485          The Shire
## 3       47.5       4378              Rohan
## 4       47.5       4378             Mordor
## 5       47.5       4507          The Shire
## 6       47.6       4620          The Shire
```
---
## Rows and columns

To change the name use the *colnames()* functions

To get a column use the column number like a vector index

```r
colnames(db1) # It shows column names
```

```
## [1] "Genome.Name"        "Contigs"            "Genome.Length"     
## [4] "GC.Content"         "PATRIC.CDS"         "Isolation_location"
```

```r
colnames(db1)[3] &lt;- "bp" # change the third column name
colnames(db1)
```

```
## [1] "Genome.Name"        "Contigs"            "bp"                
## [4] "GC.Content"         "PATRIC.CDS"         "Isolation_location"
```

```r
colnames(db1)[3] # Get only the third column
```

```
## [1] "bp"
```

---
## Rows and columns
How to set row names:

```r
rownames(db1) # It shows row names
```

```
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
## [16] "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30"
## [31] "31" "32" "33" "34" "35" "36" "37" "38" "39" "40" "41" "42" "43" "44"
```

```r
rownames(db1) &lt;- db1$Genome.Name # We set as rownames all values from column
```

---
## Rows and columns


```r
head(db)
```

```
##                                          Genome.Name Contigs Genome.Length
## 1 Yersinia pestis biovar Orientalis str. AS200901539     250       4572127
## 2 Yersinia pestis biovar Orientalis str. AS200902147     277       4592682
## 3 Yersinia pestis biovar Orientalis str. AS200901434     237       4572981
## 4 Yersinia pestis biovar Orientalis str. AS200901509     263       4605070
## 5                               Yersinia pestis 2501     201       4593919
## 6                                Yersinia pestis 24H     140       4492822
##   GC.Content PATRIC.CDS Isolation_location
## 1       47.5       4398           Isengard
## 2       47.5       4485          The Shire
## 3       47.5       4378              Rohan
## 4       47.5       4378             Mordor
## 5       47.5       4507          The Shire
## 6       47.6       4620          The Shire
```
---
## Rows and columns

```r
head(db1)
```

```
##                                                                                           Genome.Name
## Yersinia pestis biovar Orientalis str. AS200901539 Yersinia pestis biovar Orientalis str. AS200901539
## Yersinia pestis biovar Orientalis str. AS200902147 Yersinia pestis biovar Orientalis str. AS200902147
## Yersinia pestis biovar Orientalis str. AS200901434 Yersinia pestis biovar Orientalis str. AS200901434
## Yersinia pestis biovar Orientalis str. AS200901509 Yersinia pestis biovar Orientalis str. AS200901509
## Yersinia pestis 2501                                                             Yersinia pestis 2501
## Yersinia pestis 24H                                                               Yersinia pestis 24H
##                                                    Contigs      bp GC.Content
## Yersinia pestis biovar Orientalis str. AS200901539     250 4572127       47.5
## Yersinia pestis biovar Orientalis str. AS200902147     277 4592682       47.5
## Yersinia pestis biovar Orientalis str. AS200901434     237 4572981       47.5
## Yersinia pestis biovar Orientalis str. AS200901509     263 4605070       47.5
## Yersinia pestis 2501                                   201 4593919       47.5
## Yersinia pestis 24H                                    140 4492822       47.6
##                                                    PATRIC.CDS
## Yersinia pestis biovar Orientalis str. AS200901539       4398
## Yersinia pestis biovar Orientalis str. AS200902147       4485
## Yersinia pestis biovar Orientalis str. AS200901434       4378
## Yersinia pestis biovar Orientalis str. AS200901509       4378
## Yersinia pestis 2501                                     4507
## Yersinia pestis 24H                                      4620
##                                                    Isolation_location
## Yersinia pestis biovar Orientalis str. AS200901539           Isengard
## Yersinia pestis biovar Orientalis str. AS200902147          The Shire
## Yersinia pestis biovar Orientalis str. AS200901434              Rohan
## Yersinia pestis biovar Orientalis str. AS200901509             Mordor
## Yersinia pestis 2501                                        The Shire
## Yersinia pestis 24H                                         The Shire
```
---
## Cleaning up
To remove a column assign a __NULL__ value to it

```r
db1$contigs &lt;- NULL # delete the column
```

If you want to remove an __object__ from R use

```r
rm(x)
```
It will free your memory from that specified __object__

The __object__ will disappear from the __environment tab__
---
## Accessing the data frame 
Extract columns and rows from a data frame (almost) like you access a __vector__

You can use the position indexes inside square brackets

First value is the row, the second the column

You can use position or names if you already set up row/column names

```r
dataframe_name[1, 1]
dataframe_name["row_name", "column_name"]
```
If don't specify one of the two values you get all elements (All rows/All columns)

```r
dataframe_name[,1] # all rows, first column
dataframe_name[1,] # first row, all column
```


---

```r
dataframe_name["row_name", "column_name"]
dataframe_name[row_index, column_index]
dataframe_name[ , "column_name"]
dataframe_name[ , column_index]
dataframe_name["row_name", ]
dataframe_name[row_index,]
dataframe_name[ , c("column_1_name", "column_2_name")]
dataframe_name[ , c(first_column_index, second_column_index)]
dataframe_name[c("row_1_name", "row_2_name"), ]
dataframe_name[c(first_row_index, second_row_index), ]
dataframe_name[ , c(first_column_index : last_column_index)]
dataframe_name[c(first_row_index : last_row_index),]
```
You can mix and match different ways to access the data
db[1,4] # First rown and 4th column
db[1,"Contigs"] #First row and column "Contigs"
db[35:78,] # From row 35 to 78 and all columns
db[,c(4,5)] #All rows and the 4th and 5th column


---
class: inverse, middle
.pull-left[
## Remember the typeof() function?
]
.pull-right[![](img/ein2.gif)]
---
## Object type
With the various form of extraction you get similar results but differerent data types

```r
dataframe_name[column_index]
dataframe_name[[column_index]] 
dataframe_name[, column_index] # Pay attention to the comma
dataframe_name$column_index
dataframe_name$column_index[row_index]
```
Assign these values to a new __object__

Look at how it appears in the environment


---
## Not Available
In R, missing values are represented by the symbol NA (not available)
To test for missing values

```r
y &lt;- c(1,2,3,NA)
is.na (y) #find which value is missing
```

```
## [1] FALSE FALSE FALSE  TRUE
```
To remove missing values from a data frame:

```r
db2 &lt;- db1[complete.cases(db1), ] # we remove all those rows having NA values
```
---
## Data frame functions
*Table* produces a table of counts. It creates tabular results of categorical variables

```r
table(db1$Isolation.Site) 
```
*gsub* takes an input value and replace it with another one

```r
db2$Isolation.Site&lt;-gsub("Respiratory","Lungs",db2$Isolation.Site) # the word ‚ÄúRespiratory‚Äù is replaced with ‚ÄúLungs‚Äù
```
*unique* identify and eliminate duplicated values in an object. The object can be a vector or
a data frame. On data frames the function removes duplicated rows

```r
country &lt;- db2$Isolation.Country
unique_country &lt;- unique(country)
```
---
## Functions on data frames
How to check if a value is present in a column or vector:

```r
value %in% vector
value %in% dataframe_name$column_name
```
To extract the first location that has the value of interest:

```r
match("value", dataframe_name$column_name)
match("Italy", db2$Isolation.Country)
```
---
## Binding
To combine two columns into a new one:

```r
paste(dataframe_name$column_name_1, dataframe_name$column_name_2, sep=‚Äù ‚Äú)
db2$Genome&lt;-paste(db2$Genome_ID,db2$Genome_Name,sep=" ") # create a new column pasting the other two
```
*cbind* and *rbind* are functions which can combine together several vectors of the same
length

*cbind* combines vectors as columns
*rbind* combines them as rows

```r
new_c &lt;- rep("Illumina",1044) # create a vector composed of 1044 values. Not asked for the exam
db2 &lt;- cbind (db2,new_c) # new_c is a new a column of the data frame
```

```r
new_r &lt;- db2[1,] # new vector containing the first row of data frame
new_r[1,1] &lt;- "1280_14681_2" # change the first value of the vector
db2 &lt;- rbind(db2,new_r) #new_r now is a new row of the data frame
db2 &lt;- db2 [-c(1045),] # remove the row ‚Äúnew_r‚Äù
```
---
# Functions
Sort a data frame in R (by default, sorting is ASCENDING)

```r
dataframe_name &lt;- dataframe_name[order(dataframe_name$column), ]
db2&lt;- db2[order(db2$Contigs),] # sort the whole data frame by column ‚ÄúContigs‚Äù
```

```r
length(dataframe_name$column_name)
length(db2$Genome_ID) #1044
```
*max* returns the maximum value of a numeric vector or column
*min* returns the minimum value of a numeric vector or column
*range* it outputs the smallest and largest values of the numeric vector or column

```r
max(db2$Contigs) #100
min(db2$Contigs) #2
range(db2$Contigs)
```
---
class: inverse, middle
## Good things come in small packages
---
## Install and load libraries
R, by default, only comes with a restricted number of functions

To extend the functionalities we can install external packages 

To install a package in R:

install.packages("library_name")

after you have installed you can load it with
library(library_name)
Example:

```r
# There's a time and place for everything
# but do not run this code now
install.packages(‚Äúggplot2‚Äù)
library(ggplot2)
```
---
# Dplyr
dplyr is a package for data manipulation, providing a consistent set of functions that help
you solve the most common data manipulation challenges

```r
install.packages (‚Äúdplyr‚Äù)
library (dplyr)
```
In order to combine two data frames, at least one column must be present in both data
frames and have the same header
colnames(db2) #
colnames(res) #

```r
full &lt;- full_join(res,db2,by="Genome_ID")
semi &lt;- semi_join(res,db2,by="Genome_ID")
left &lt;- left_join(res,db2,by="Genome_ID")
right &lt;- right_join(res,db2,by="Genome_ID")
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url(img/midi_trans.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 110px;
  height: 128px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
