---
title: "Introduction to R - part 3"
subtitle: "ðŸ§‰"
author: "Tiago Nardi"
institute: "University of Pavia"
output:
  xaringan::moon_reader:
    css: [extra.css, xaringan-themer.css]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    includes:
      after_body: insert-logo.html
---
```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

```
```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
  #style_mono_accent(
  style_duo(
  primary_color = "#f2DB86",
  #base_color = "#B2284B",
  secondary_color = "#32577F",

)
library(gt)

# style_duo_accent(primary_color = "#002fa7", secondary_color = "#C5A900")

```
class: inverse, middle, center
# Plot design
---
class: middle
# Histograms
A histogram is a representation of the distribution of __numerical__ data

The entire range of values is divided into __intervals__ (bins) and then the function counts how many values fall into each interval

The wideness of the column is dependant of the choosen interval
---
# Histograms
.pull-left[
Histogram plot with default values
```{r hist1, fig.show = 'hide'}
db <- read.csv("patric_redux.csv")
hist(db$GC.Content)
```
]
.pull-right[
```{r ref.label='hist1',echo = FALSE, dev.args = list(bg = "transparent")}
```
]
---
# Histograms

``` {r , eval= FALSE}
hist(dataframe_name$column,
     breaks = "value", col = "colour_name",
     border = "colour_name", main = "Title", 
     xlab = "x_name", ylab = "y_name")
```
breaks: a single number giving the number of cells for the histogram

col: a colour to be used to fill the bars, you can use the name of ("lightblue", "red", see http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf ) the RGB or the hex format

border: the color of the border around the bars. The default is to use the standard foreground color

main, xlab, ylab: these arguments give labels to title and axis
---
class: inverse, middle
# Exercise
.pull-left[
``` {r , eval= FALSE}
hist(dataframe_name$column,
     breaks = "value",
     col = "colour_name",
     border = "colour_name", 
     main = "Title", 
     xlab = "x_name", 
     ylab = "y_name")
```
#### Try to get a histogram using the patric_redux.csv, draw the genome length, use appropriate labels and use a colour
]
.pull-right[
![](img/cowboy-bebop-cowboy.gif)]
---
```{r hist2, echo = FALSE, dev.args = list(bg = "transparent")}
hist(db$Genome.Length, breaks = 20, 
     main = "Genome Length Distribution",
     col = "#32577F",border="black",xlab="Length")
```

```{r, eval = FALSE}
hist(db$Genome.Length, breaks = 20,
     main = "Genome Length Distribution",
     col = "#32577F",border="black",xlab="Length")
```
---
class: middle
## Saving graphs
To save a graph
```{r, eval=FALSE}
pdf("Graph_name.pdf")
graph_command # any graph, including hist()
dev.off()
```

This will save whatever you draw (*graph_command*) in your __present working directory__

You can also use the *export* function in the __Plot tab__
---
class: middle
## Barplot
A barplot shows the relationship between categorical variables. Each variable is
represented as a bar, and the bar size represents its numeric value


In R, barplot() function computes a barplot of the given grouped values

For the bar height you need a quantitative variable

For the bar name you need a qualitative variable
---
class: hide-logo, inverse
.pull-left[
### Try to make one barplot, using the subsetted table, with the *ID* as qualitative and *Contigs* as quantitative variable]
.pull-right[
![](img/cowboy-bebop-cowboy.gif)]
```{r, eval=TRUE}
# I'm using a smaller table for readability sake
db_sub <- subset(
  db,
  db$Isolation_location == "Barad-dur" | 
    db$Isolation_location == "Isengard" )
```

```{r eval=FALSE}
barplot(
  height=quantitative_variable,
  names=qualitative_variable)
```
---
## Barplot
```{r, eval=TRUE, dev.args = list(bg = "transparent"),echo=FALSE}
barplot(height=db_sub$Contigs, names=db_sub$ID,col = "#32577F")
```
---
class: middle
## Barplot
```{r, eval=FALSE}
barplot(table, col = "colour_name",
        horiz = T, main = "Title",
        xlab = "x_name", ylab = "y_name",
        width=c(0.1,0.2,3,1.5,0.3),
        col=c("color","#HEX"), space=c(1,3))
```
You can edit labels, as you have done before with the histogram, changing bar colours, display the bars horizontally, modify the space between the bars or even their width

Remember that you can check the __help__ using *?barplot*

---
class: middle
## A modified barplot
.pull-left[
```{r, eval=TRUE, echo=FALSE,dev.args = list(bg = "transparent")}
barplot(height=db_sub$PATRIC.CDS,names=db_sub$ID,
        horiz=T,
        width=c(0.1,0.2,0.3,1.4,0.3),
        col=c("#00A0B0","#6A4A3C","#CC333F","#EB6841","#EDC951"))
```

]

.pull-right[
```{r, eval=FALSE,}
barplot(height=db_sub$PATRIC.CDS,
        names=db_sub$ID,
        horiz=T,
        width=c(0.1,0.2,0.3,
                1.4,0.3),
        col=c("#00A0B0",
              "#6A4A3C",
              "#CC333F",
              "#EB6841",
              "#EDC951"))
```  
  
]
---
## Scatter plot
A scatter plot shows the relationship between __two numerical__ variables

Displayed as a collection of points, each having one variable determining x axis and the other variable determining the position on the y axis

In R, we can use the generic function *plot()*
```{r , eval=FALSE}
plot(x,y, col = "colour_name",
main = "Title", xlab = "x_name", ylab = "y_name")
```
<img src="img/cowboy-bebop-cowboy.gif" style="width: 30%"/>

Draw a scatterplot with *Genome.Length* and *Contigs* number as the numerical variables
---

```{r, echo=FALSE}
plot(db$Genome.Length,db$Contigs,col= as.numeric(as.factor(db$Source)),cex = 2,pch=16)
```
```{r, eval=FALSE}
plot(db$Genome.Length,db$Contigs,
     col= as.numeric(as.factor(db$Source)),cex = 2,pch=16)
```
---
## Colouring - not mandatory
To assign a colour we need to use a __factor__ (qualitative variable)

The variable can be already assigned (es. *Source*) or we can create one using the values in the table

We need a __vector__ of colours of the same length of the list of factors
```{r, eval=TRUE,echo=TRUE}
levels(as.factor(db$Source))
```
__Factors__ are assigned in alphabetical order, so the colours should follow the same order
```{r, eval=TRUE,echo=TRUE}
s_colours <- c("firebrick","darkgoldenrod1","cornflowerblue",
               "violetred","darkorange","chartreuse4")
```
---
## Coloured by Source
.pull-left[
```{r, echo=FALSE}
plot(db$Genome.Length,db$Contigs,col= s_colours[(as.factor(db$Source))],cex = 2,pch=17)
```
]
.pull-right[
```{r, echo=TRUE,eval=FALSE}
plot(db$Genome.Length,db$Contigs,
     col= s_colours[
       (as.factor(db$Source))],
     cex = 2,pch=17)
```
I use a __vector__ of colours, each value is assigned to a row of the data frame depending on the __level__ of *db$Source*
]
---
## Using the df values 
Instead of groups already present in the dataframe you can also create grouping basing on values
```{r, eval=TRUE}
db$group <- factor(ifelse(db$Genome.Length < 4400000,"low",
                          ifelse(db$Genome.Length > 4800000 ,
                                 "high","medium")))
```
We can divide the samples according to *Genome.Lenght*, creating a new column

I used a logical function that assign different values on the logical condition
```{r, eval=FALSE}
ifelse(condition, if TRUE then, if FALSE then)
```
Then we assign to a __vector__ three colours already present in R
``````{r, eval=TRUE}
plot_colours <- c("firebrick","royalblue","mediumseagreen")
```
---
class: hide-logo
```{r, eval=TRUE,echo=FALSE}
plot(db$Genome.Length,db$Contigs,col=plot_colours[db$group],pch=17)
abline(v=4400000, col="royalblue", lwd=3, lty=2)
abline(v=4800000, col="firebrick", lwd=3, lty=2)
```

```{r, eval=FALSE,echo=TRUE}
plot(db$Genome.Length,db$Contigs,col=plot_colours[db$group],pch=17)
abline(v=4400000, col="royalblue", lwd=3, lty=2)
abline(v=4800000, col="firebrick", lwd=3, lty=2)
```
---
class: middle
## Legend
We can add a legend to a plot

First we draw the plot, then we use the function *legend* 
```{r, eval=FALSE}
legend(position,legend=vector_of_labels, col=vector_of_colours)
```
The position can be specified with any of these __strings__
```
"bottomright", "bottom", "bottomleft", "left", 
"topleft", "top", "topright", "right" "center"
```

---
```{r, echo=FALSE,eval=TRUE}
plot(db$Genome.Length,db$Contigs,
     col= s_colours[
       (as.factor(db$Source))],
     cex = 2,pch=17)
legend("topright",legend=levels(as.factor(db$Source)),lwd = 3, col = s_colours)
```
```{r, eval=FALSE}
legend("topright",legend=levels(as.factor(db$Source)),
       lwd = 3, col = s_colours)
```
---
class: middle
## Exercises
Make a histogram of the *PATRIC.CDS* 

Make a barplot to draw the number of samples for each *Species*

Draw a scatterplot using the *GC.Content* and *PATRIC.CDS*

---
class: middle
## Extra - Plotting
.pull-left[
You can chose how to draw points using different __pch__ values

Combine shapes and colours to make the plot more readable

]
.pull-right[![](img/pch.png)]

---
class: middle
## Extra - Plotting
.pull-left[
The same is valid for __lty__, used to specifcy the type of lines in a plot]
.pull-right[![](img/lty.png)]
---
class: middle
## Extra - Data visualisation
You can manipulate single elements in the plot

You can add lines, curves, labels and other elements

For example you can add a line at a specific value
``` {r, eval= FALSE}
abline(h = 1, lty = 2)
```

---
class: middle
## Extra - resources
You can control many settings and aspect in the graphical output using the library __ggplot2__

This library is extremely useful for data visualisation

https://r-graphics.org/ is a good reference for what you make with __ggplot2__
---
class: middle
## Extra - Other resources

https://socviz.co/  
Introduction to Data visualisation, principles to use to make effective plots


